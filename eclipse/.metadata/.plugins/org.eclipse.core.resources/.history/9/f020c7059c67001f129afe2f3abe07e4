package Basil.module.combat;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.lwjgl.input.Keyboard;

import Basil.Client;
import Basil.module.*;
import Basil.module.Module;
import Basil.utils.Rotation;
import de.Hero.settings.Setting;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.C03PacketPlayer;

public class AimBot extends Module{
	
	EntityLivingBase best;
	public boolean inversed = false;

	public AimBot() {
		super("Aimbot", Keyboard.KEY_G, Category.COMBAT);
	}
	
	public void setup() {
		Client.sm.rSetting(new Setting("Range", this, 8, 4, 25, false));
		Client.sm.rSetting(new Setting("Speed Min", this, 60, 30, 360, true));
		Client.sm.rSetting(new Setting("Speed Max", this, 90, 30, 360, true));
		Client.sm.rSetting(new Setting("Priority FOV", this, 45, 15, 180, true));
	}
	
	public void inverse() {
		inversed = !inversed;
	}
	
	@Override
	public void onFrame() {
		if (!this.isToggled() || !(mc.thePlayer.getHealth() > 0)) {
			return;
		}
		
		ArrayList<Setting> settings = Client.sm.getSettingsByMod(this);
		
		boolean f = false;
		best = null;
		
		for (Iterator<Entity> entities = mc.theWorld.loadedEntityList.iterator(); entities.hasNext();) {
			Object theObject = entities.next();
			if (theObject instanceof EntityLivingBase) {
				EntityLivingBase entity = (EntityLivingBase) theObject;
				if (entity instanceof EntityPlayerSP) {
					continue;
				}
				if (!(entity instanceof EntityPlayer)) {
					continue;
				}
				if (mc.thePlayer.getDistanceToEntity(entity) > settings.get(0).getValDouble() * 2) {
					continue;
				}
				if (Rotation.getYawDistToEntity(entity) > settings.get(2).getValDouble()) {
					continue;
				}
				
				if (!f || mc.thePlayer.getDistanceToEntity(entity) < mc.thePlayer.getDistanceToEntity(best)) {
					best = entity;
					f = true;
				}
			}
		}
		
		if (best == null) {
			f = false;
			try {
				best = (EntityLivingBase) mc.theWorld.loadedEntityList.get(0);
			}catch(Exception e) {
				best = null;
			}
			
			for (Iterator<Entity> entities = mc.theWorld.loadedEntityList.iterator(); entities.hasNext();) {
				Object theObject = entities.next();
				if (theObject instanceof EntityLivingBase) {
					EntityLivingBase entity = (EntityLivingBase) theObject;
					if (entity instanceof EntityPlayerSP) {
						continue;
					}
					if (!(entity instanceof EntityPlayer)) {
						continue;
					}
					if (mc.thePlayer.getDistanceToEntity(entity) > settings.get(0).getValDouble() * 2) {
						continue;
					}
					
					if (!f || mc.thePlayer.getDistanceToEntity(entity) < mc.thePlayer.getDistanceToEntity(best)) {
						best = entity;
						f = true;
					}
				}
			}
		}
		
		if (f && best.isEntityAlive() && best != null) {
			/*float yaw = Rotation.getRotationTo(best)[0];
			float pYaw = mc.thePlayer.rotationYaw;
			if (inversed) {
				if (yaw > 0) {
					yaw = -(180 - yaw);
				}else {
					yaw = 180 + yaw;
				}
			}
			float s = (float) (settings.get(1).getValDouble() / mc.getDebugFPS() * 5);
			float x = Rotation.getYawDistToEntity(best, yaw);
			float d0 = x * x;
			if (x < 0) {
				s = -s;
			}
			if (Math.abs(s) < Math.abs(x)) {
				x = s;
			}
			float newYaw = mc.thePlayer.rotationYaw + x;
			if (newYaw > 180) {
				newYaw -= 180;
				newYaw = -(180 - newYaw);
			}
			if (newYaw < -180) {
				newYaw += 180;
				newYaw = 180 + newYaw;
			}
			x = Rotation.getPitchDistToEntity(best);
			d0 += x * x;
			if (x < 0) {
				s = -s;
			}
			if (Math.abs(s) < Math.abs(x)) {
				x = s;
			}
			float newPitch = mc.thePlayer.rotationYaw + x;
			if (newPitch > 180) {
				newPitch -= 180;
				newPitch = -(180 - newPitch);
			}
			if (newPitch < -180) {
				newPitch += 180;
				newPitch = 180 + newPitch;
			}
			d0 = (float) Math.sqrt(Math.abs(d0));
			if (Math.abs(d0) > 30) {
				float dy = newPitch - newYaw, dp = newYaw - newPitch;
				float d1 = (float) Math.max(1, Math.sqrt(Math.abs(dy * dy + dp * dp)));
				dy /= d1;
				dp /= d1;
				float ry = (float) (Math.random() * 30 - 15);
				float rp = (float) (Math.random() * 30 - 15);
				newYaw = newYaw + dy * ry * 5 / d0;
				newPitch = newPitch + dp * rp * 5 / d0;
			}
			if (newYaw > 180) {
				newYaw -= 180;
				newYaw = -(180 - newYaw);
			}
			if (newYaw < -180) {
				newYaw += 180;
				newYaw = 180 + newYaw;
			}
			if (newPitch > 180) {
				newPitch -= 180;
				newPitch = -(180 - newPitch);
			}
			if (newPitch < -180) {
				newPitch += 180;
				newPitch = 180 + newPitch;
			}
			System.out.println(newYaw + " " + newPitch);
			mc.thePlayer.rotationYaw = newYaw;
			mc.thePlayer.rotationPitch = newPitch;*/
			float yaw = Rotation.getRotationTo(best)[0];
			float pitch = Rotation.getRotationTo(best)[1];
			float pYaw = mc.thePlayer.rotationYaw;

			// Inversion logic, if applicable
			if (inversed) {
			    yaw = (yaw > 0) ? -(180 - yaw) : 180 + yaw;
			}

			// Calculate yaw distance
			float yawDist = Rotation.getYawDistToEntity(best, yaw);

			// Dynamically adjust step size based on proximity to target
			float proximityFactor = Math.abs(yawDist) / 90.0f; // Closer to target, smaller factor
			proximityFactor = Math.max(0.1f, proximityFactor); // Avoid too small a factor
			float s = (float) (settings.get(1).getValDouble() / mc.getDebugFPS() * 5 * proximityFactor);

			// Apply the calculated adjustment
			if (Math.abs(s) < Math.abs(yawDist)) {
			    yawDist = Math.signum(yawDist) * s;
			}
			float newYaw = pYaw + yawDist;

			// Normalize yaw to be within [-180, 180]
			if (newYaw > 180) {
			    newYaw -= 360;
			} else if (newYaw < -180) {
			    newYaw += 360;
			}

			// Calculate pitch distance
			float pitchDist = Rotation.getPitchDistToEntity(best);

			// Apply pitch adjustment similarly
			if (Math.abs(s) < Math.abs(pitchDist)) {
			    pitchDist = Math.signum(pitchDist) * s;
			}
			float newPitch = mc.thePlayer.rotationPitch + pitchDist;

			// Clamp pitch to the [-90, 90] range
			newPitch = Math.max(-90, Math.min(90, newPitch));

			float d0 = (float) Math.sqrt(yawDist * yawDist + pitchDist * pitchDist);

			if (Math.abs(d0) > 30) {
			    // Smooth out corrections if necessary
			    float dy = newPitch - newYaw;
			    float dp = newYaw - newPitch;
			    float d1 = (float) Math.max(1, Math.sqrt(dy * dy + dp * dp));
			    dy /= d1;
			    dp /= d1;

			    float ry = (float) (Math.random() * 30 - 15);
			    float rp = (float) (Math.random() * 30 - 15);

			    newYaw += dy * ry * 5 / d0;
			    newPitch += dp * rp * 5 / d0;

			    // Re-clamp pitch after random adjustments
			    newPitch = Math.max(-90, Math.min(90, newPitch));
			}

			// Final normalization of yaw
			if (newYaw > 180) {
			    newYaw -= 360;
			} else if (newYaw < -180) {
			    newYaw += 360;
			}

			// Debugging output to track yaw and pitch values
			System.out.println("Yaw




		}
		super.onUpdate();
	}
}
